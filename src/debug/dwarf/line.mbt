/// Copyright 2015 The Go Authors. All rights reserved.
/// Use of this source code is governed by a BSD-style
/// license that can be found in the LICENSE file.

///|
/// A LineReader reads a sequence of LineEntry structures from a DWARF
/// "line" section for a single compilation unit. LineEntries occur in
/// order of increasing PC and each LineEntry gives metadata for the
/// instructions from that LineEntry's PC to just before the next
/// LineEntry's PC. The last entry will have the LineEntry.end_sequence field set.
pub struct LineReader {
  buf : Buf
  /// Original .debug_line section data. Used by Seek.
  section : @slice.Slice[Byte]
  /// .debug_str
  /// .debug_line_str
  str : @slice.Slice[Byte]
  line_str : @slice.Slice[Byte]
  /// Header information
  mut version : UInt
  mut addrsize : Int
  mut segment_selector_size : Int
  mut min_instruction_length : Int
  mut max_ops_per_instruction : Int
  mut default_is_stmt : Bool
  mut line_base : Int
  mut line_range : Int
  mut opcode_base : Int
  mut opcode_lengths : Array[Int]
  mut directories : Array[@string.View]
  mut file_entries : Array[LineFile?]
  /// section offset of line number program
  /// section offset of byte following program
  mut program_offset : Offset
  mut end_offset : Offset
  /// initial length of file_entries
  mut initial_file_entries : Int
  /// Current line number program state machine registers
  /// public state
  /// private state
  mut state : LineEntry
  mut file_index : Int
}

///|
/// A LineEntry is a row in a DWARF line table.
pub struct LineEntry {
  /// Address is the program-counter value of a machine
  /// instruction generated by the compiler. This LineEntry
  /// applies to each instruction from Address to just before the
  /// Address of the next LineEntry.
  mut address : UInt64
  /// OpIndex is the index of an operation within a VLIW
  /// instruction. The index of the first operation is 0. For
  /// non-VLIW architectures, it will always be 0. Address and
  /// OpIndex together form an operation pointer that can
  /// reference any individual operation within the instruction
  /// stream.
  mut op_index : Int
  /// File is the source file corresponding to these
  /// instructions.
  mut file : LineFile?
  /// Line is the source code line number corresponding to these
  /// instructions. Lines are numbered beginning at 1. It may be
  /// 0 if these instructions cannot be attributed to any source
  /// line.
  mut line : Int
  /// Column is the column number within the source line of these
  /// instructions. Columns are numbered beginning at 1. It may
  /// be 0 to indicate the "left edge" of the line.
  mut column : Int
  /// IsStmt indicates that Address is a recommended breakpoint
  /// location, such as the beginning of a line, statement, or a
  /// distinct subpart of a statement.
  mut is_stmt : Bool
  /// BasicBlock indicates that Address is the beginning of a
  /// basic block.
  mut basic_block : Bool
  /// PrologueEnd indicates that Address is one (of possibly
  /// many) PCs where execution should be suspended for a
  /// breakpoint on entry to the containing function.
  ///
  /// Added in DWARF 3.
  mut prologue_end : Bool
  /// EpilogueBegin indicates that Address is one (of possibly
  /// many) PCs where execution should be suspended for a
  /// breakpoint on exit from this function.
  ///
  /// Added in DWARF 3.
  mut epilogue_begin : Bool
  /// ISA is the instruction set architecture for these
  /// instructions. Possible ISA values should be defined by the
  /// applicable ABI specification.
  ///
  /// Added in DWARF 3.
  mut isa : Int
  /// Discriminator is an arbitrary integer indicating the block
  /// to which these instructions belong. It serves to
  /// distinguish among multiple blocks that may all have with
  /// the same source file, line, and column. Where only one
  /// block exists for a given source position, it should be 0.
  ///
  /// Added in DWARF 3.
  mut discriminator : Int
  /// EndSequence indicates that Address is the first byte after
  /// the end of a sequence of target machine instructions. If it
  /// is set, only this and the Address field are meaningful. A
  /// line number table may contain information for multiple
  /// potentially disjoint instruction sequences. The last entry
  /// in a line table should always have EndSequence set.
  mut end_sequence : Bool
} derive(Show)

///|
/// A LineFile is a source file referenced by a DWARF line table entry.
pub struct LineFile {
  name : @string.View
  /// Implementation defined modification time, or 0 if unknown
  /// File length, or 0 if unknown
  mtime : UInt64
  length : Int
} derive(Show)

///|
/// LineReader returns a new reader for the line table of compilation
/// unit cu, which must be an Entry with tag TagCompileUnit.
///
/// If this compilation unit has no line table, it returns None, None.
pub fn Data::line_reader(d : Data, cu : Entry) -> LineReader? raise {
  if d.line.length() == 0 {
    /// No line tables available.
    return None
  }

  /// Get line table information from cu.
  let off = match cu.val(AttrStmtList) {
    Some(Int64(off)) => off
    _ => return None /// cu has no line table.
  }
  if off < 0L || off > d.line.length().to_int64() {
    raise DecodeError::new("line", 0, "AttrStmtList value out of range")
  }
  /// AttrCompDir is optional if all file names are absolute. Use
  /// the empty string if it's not present.
  let comp_dir = match cu.val(AttrCompDir) {
    Some(String(comp_dir)) => comp_dir
    _ => ""
  }

  /// Create the LineReader.
  let u = d.unit[d.offset_to_unit(cu.offset)]
  let buf = make_buf(
    d,
    u,
    "line",
    off.to_int().reinterpret_as_uint(),
    d.line[off.to_int():],
  )
  /// The compilation directory is implicitly directories[0].
  let r = LineReader::{
    buf,
    section: d.line,
    str: d.str,
    line_str: d.line_str,
    version: 0U,
    addrsize: 0,
    segment_selector_size: 0,
    min_instruction_length: 0,
    max_ops_per_instruction: 0,
    default_is_stmt: false,
    line_base: 0,
    line_range: 0,
    opcode_base: 0,
    opcode_lengths: [],
    directories: [],
    file_entries: [],
    program_offset: 0,
    end_offset: 0,
    initial_file_entries: 0,
    state: LineEntry::{
      address: 0UL,
      op_index: 0,
      file: None,
      line: 0,
      column: 0,
      is_stmt: false,
      basic_block: false,
      prologue_end: false,
      epilogue_begin: false,
      isa: 0,
      discriminator: 0,
      end_sequence: false,
    },
    file_index: 0,
  }

  /// Read the header.
  r.read_header(comp_dir)

  /// Initialize line reader state.
  r.reset()
  Some(r)
}

///|
/// UnknownPCError is the error returned by LineReader.scan_pc when the
/// seek PC is not covered by any entry in the line table.
pub suberror UnknownPCError

///|
/// Helper function to copy LineEntry state
fn copy_line_entry(dst : LineEntry, src : LineEntry) -> @unit.T {
  dst.address = src.address
  dst.op_index = src.op_index
  dst.file = src.file
  dst.line = src.line
  dst.column = src.column
  dst.is_stmt = src.is_stmt
  dst.basic_block = src.basic_block
  dst.prologue_end = src.prologue_end
  dst.epilogue_begin = src.epilogue_begin
  dst.isa = src.isa
  dst.discriminator = src.discriminator
  dst.end_sequence = src.end_sequence
}

///|
/// readHeader reads the line number program header from r.buf and sets
/// all of the header fields in r.
fn LineReader::read_header(r : LineReader, comp_dir : String) -> @unit.T raise {
  let buf = r.buf

  /// Read basic header fields [DWARF2 6.2.4].
  let hdr_offset = buf.off
  let (unit_length, dwarf64) = buf.unit_length()
  r.end_offset = buf.off + unit_length
  if r.end_offset > buf.off + buf.data.length().reinterpret_as_uint() {
    raise DecodeError::new(
      "line",
      hdr_offset,
      "line table end \{r.end_offset} exceeds section size \{buf.off + buf.data.length().reinterpret_as_uint()}",
    )
  }
  r.version = buf.uint16()
  if buf.err is None && (r.version < 2U || r.version > 5U) {
    /// DWARF goes to all this effort to make new opcodes
    /// backward-compatible, and then adds fields right in
    /// the middle of the header in new versions, so we're
    /// picky about only supporting known line table
    /// versions.
    raise DecodeError::new(
      "line",
      hdr_offset,
      "unknown line table version \{r.version}",
    )
  }
  if r.version >= 5U {
    r.addrsize = buf.uint8().reinterpret_as_int()
    r.segment_selector_size = buf.uint8().reinterpret_as_int()
  } else {
    r.addrsize = buf.format.addrsize()
    r.segment_selector_size = 0
  }
  let header_length : Offset = if dwarf64 {
    buf.uint64().to_uint()
  } else {
    buf.uint32()
  }
  let program_offset = buf.off + header_length
  if program_offset > r.end_offset {
    raise DecodeError::new(
      "line",
      hdr_offset,
      "malformed line table: program offset \{program_offset} exceeds end offset \{r.end_offset}",
    )
  }
  r.program_offset = program_offset
  r.min_instruction_length = buf.uint8().reinterpret_as_int()
  if r.version >= 4U {
    /// [DWARF4 6.2.4]
    r.max_ops_per_instruction = buf.uint8().reinterpret_as_int()
  } else {
    r.max_ops_per_instruction = 1
  }
  r.default_is_stmt = buf.uint8() != 0U
  let line_base_uint = buf.uint8()
  r.line_base = if line_base_uint >= 128U {
    line_base_uint.reinterpret_as_int() - 256
  } else {
    line_base_uint.reinterpret_as_int()
  }
  r.line_range = buf.uint8().reinterpret_as_int()

  /// Validate header.
  if buf.err is Some(err) {
    raise err
  }
  if r.max_ops_per_instruction == 0 {
    raise DecodeError::new(
      "line", hdr_offset, "invalid maximum operations per instruction: 0",
    )
  }
  if r.line_range == 0 {
    raise DecodeError::new("line", hdr_offset, "invalid line range: 0")
  }

  /// Read standard opcode length table. This table starts with opcode 1.
  r.opcode_base = buf.uint8().reinterpret_as_int()
  r.opcode_lengths = Array::make(r.opcode_base, 0)
  for i = 1; i < r.opcode_base; i = i + 1 {
    r.opcode_lengths[i] = buf.uint8().reinterpret_as_int()
  }

  /// Validate opcode lengths.
  if buf.err is Some(err) {
    raise err
  }
  for i = 0; i < r.opcode_lengths.length(); i = i + 1 {
    let length = r.opcode_lengths[i]
    if known_opcode_lengths.get(i) is Some(known) && known != length {
      raise DecodeError::new(
        "line",
        hdr_offset,
        "opcode \{i} expected to have length \{known}, but has length \{length}",
      )
    }
  }
  if r.version < 5U {
    /// Read include directories table.
    r.directories = [comp_dir]
    for {
      let directory = buf.string()
      if buf.err is Some(err) {
        raise err
      }
      if directory.length() == 0 {
        break
      }
      if not(path_is_abs(directory)) {
        /// Relative paths are implicitly relative to
        /// the compilation directory.
        r.directories.push(path_join(comp_dir, directory))
      } else {
        r.directories.push(directory)
      }
    }

    /// Read file name list. File numbering starts with 1,
    /// so leave the first entry nil.
    r.file_entries = [None]
    for {
      let done = r.read_file_entry()
      if done {
        break
      }
    }
  } else {
    let dir_format = r.read_lnct_format()
    let c = buf.uint().to_int()
    r.directories = Array::make(c, "")
    for i = 0; i < c; i = i + 1 {
      let (dir, _, _) = r.read_lnct(dir_format, dwarf64)
      r.directories[i] = dir
    }
    let file_format = r.read_lnct_format()
    let c = buf.uint().to_int()
    r.file_entries = Array::make(c, None)
    for i = 0; i < c; i = i + 1 {
      let (name, mtime, size) = r.read_lnct(file_format, dwarf64)
      r.file_entries[i] = Some(LineFile::{ name, mtime, length: size.to_int() })
    }
  }
  r.initial_file_entries = r.file_entries.length()
  if buf.err is Some(err) {
    raise err
  }
}

///|
/// lnctForm is a pair of an LNCT code and a form. This represents an
/// entry in the directory name or file name description in the DWARF 5
/// line number program header.
priv struct LnctForm {
  mut lnct : Int
  mut format : Format
}

///|
/// readLNCTFormat reads an LNCT format description.
fn LineReader::read_lnct_format(r : LineReader) -> Array[LnctForm] raise {
  let c = r.buf.uint8().reinterpret_as_int()
  let ret = Array::make(c, LnctForm::{ lnct: 0, format: FormString })
  for i = 0; i < c; i = i + 1 {
    ret[i].lnct = r.buf.uint().to_int()
    ret[i].format = Format::from_uint(r.buf.uint().to_uint())
  }
  ret
}

///|
/// readLNCT reads a sequence of LNCT entries and returns path information.
fn LineReader::read_lnct(
  r : LineReader,
  s : Array[LnctForm],
  dwarf64 : Bool,
) -> (@string.View, UInt64, UInt64) raise {
  let mut dir : @string.View = ""
  let mut path : @string.View = ""
  let mut mtime : UInt64 = 0UL
  let mut size : UInt64 = 0UL
  for lf in s {
    let mut str = ""
    let mut val : UInt64 = 0UL
    match lf.format {
      FormString => str = r.buf.string()
      FormStrp | FormLineStrp => {
        let off : UInt64 = if dwarf64 {
          r.buf.uint64()
        } else {
          r.buf.uint32().to_uint64()
        }
        if off.to_int().to_uint64() != off {
          raise DecodeError::new(
            "line",
            r.buf.off,
            "strp/line_strp offset out of range",
          )
        }
        let b1 = if lf.format == FormStrp {
          make_buf(r.buf.dwarf, r.buf.format, "str", 0, r.str)
        } else {
          make_buf(r.buf.dwarf, r.buf.format, "line_str", 0, r.line_str)
        }
        b1.skip(off.to_int())
        str = b1.string()
      }
      FormStrpSup =>
        /// Supplemental sections not yet supported.
        if dwarf64 {
          ignore(r.buf.uint64())
        } else {
          ignore(r.buf.uint32())
        }
      FormStrx =>
        /// .debug_line.dwo sections not yet supported.
        ignore(r.buf.uint())
      FormStrx1 => ignore(r.buf.uint8())
      FormStrx2 => ignore(r.buf.uint16())
      FormStrx3 => ignore(r.buf.uint24())
      FormStrx4 => ignore(r.buf.uint32())
      FormData1 => val = r.buf.uint8().to_uint64()
      FormData2 => val = r.buf.uint16().to_uint64()
      FormData4 => val = r.buf.uint32().to_uint64()
      FormData8 => val = r.buf.uint64()
      FormData16 => ignore(r.buf.bytes(16))
      FormDwarfBlock => ignore(r.buf.bytes(r.buf.uint().to_int()))
      FormUdata => val = r.buf.uint()
      _ => ()
    }
    match lf.lnct.reinterpret_as_uint() {
      LnctPath => path = str
      LnctDirectoryIndex => {
        if val >= r.directories.length().to_uint64() {
          raise DecodeError::new(
            "line",
            r.buf.off,
            "directory index out of range",
          )
        }
        dir = r.directories[val.to_int()]
      }
      LnctTimestamp => mtime = val
      LnctSize => size = val
      LnctMD5 => () /// Ignored.
      _ => ()
    }
  }
  if dir.length() > 0 && path.length() > 0 {
    path = path_join(dir, path)
  }
  (path, mtime, size)
}

///|
/// readFileEntry reads a file entry from either the header or a
/// DW_LNE_define_file extended opcode and adds it to r.file_entries. A
/// true return value indicates that there are no more entries to read.
fn LineReader::read_file_entry(r : LineReader) -> Bool raise {
  let name : @string.View = r.buf.string()
  if name.length() == 0 {
    return true
  }
  let off = r.buf.off
  let dir_index = r.buf.uint().to_int()
  let name : @string.View = if !path_is_abs(name) {
    if dir_index >= r.directories.length() {
      raise DecodeError::new("line", off, "directory index too large")
    }
    path_join(r.directories[dir_index], name)
  } else {
    name
  }
  let mtime = r.buf.uint()
  let length = r.buf.uint().to_int()

  /// If this is a dynamically added path and the cursor was
  /// backed up, we may have already added this entry. Avoid
  /// updating existing line table entries in this case. This
  /// avoids an allocation and potential racy access to the slice
  /// backing store if the user called Files.
  if r.file_entries.length() < r.file_entries.length() {
    let fe_len = r.file_entries.length()
    if fe_len > 0 && r.file_entries[fe_len - 1] is Some(_) {
      /// We already processed this addition.
      return false
    }
  }
  r.file_entries.push(Some(LineFile::{ name, mtime, length }))
  false
}

///|
/// updateFile updates r.state.File after r.file_index has
/// changed or r.file_entries has changed.
fn LineReader::update_file(r : LineReader) -> @unit.T {
  if r.file_index < r.file_entries.length() {
    r.state.file = r.file_entries[r.file_index]
  } else {
    r.state.file = None
  }
}

///|
/// Next sets *entry to the next row in this line table and moves to
/// the next row. If there are no more entries and the line table is
/// properly terminated, it raises @io.EOF.
///
/// Rows are always in order of increasing entry.Address, but
/// entry.Line may go forward or backward.
pub fn LineReader::next(r : LineReader, entry : LineEntry) -> @unit.T raise {
  if r.buf.err is Some(err) {
    raise err
  }

  /// Execute opcodes until we reach an opcode that emits a line
  /// table entry.
  for {
    if r.buf.data.length() == 0 {
      raise @io.EOF
    }
    let emit = r.step(entry)
    if r.buf.err is Some(err) {
      raise err
    }
    if emit {
      return
    }
  }
}

///|
/// knownOpcodeLengths gives the opcode lengths (in varint arguments)
/// of known standard opcodes.
let known_opcode_lengths : Map[Int, Int] = {}

///|
fn init {
  known_opcode_lengths[LnsCopy.reinterpret_as_int()] = 0
  known_opcode_lengths[LnsAdvancePc.reinterpret_as_int()] = 1
  known_opcode_lengths[LnsAdvanceLine.reinterpret_as_int()] = 1
  known_opcode_lengths[LnsSetFile.reinterpret_as_int()] = 1
  known_opcode_lengths[LnsNegateStmt.reinterpret_as_int()] = 0
  known_opcode_lengths[LnsSetBasicBlock.reinterpret_as_int()] = 0
  known_opcode_lengths[LnsConstAddPc.reinterpret_as_int()] = 0
  known_opcode_lengths[LnsSetPrologueEnd.reinterpret_as_int()] = 0
  known_opcode_lengths[LnsSetEpilogueBegin.reinterpret_as_int()] = 0
  known_opcode_lengths[LnsSetISA.reinterpret_as_int()] = 1
  /// LnsFixedAdvancePC takes a uint8 rather than a varint; it's
  /// unclear what length the header is supposed to claim, so
  /// ignore it.
}

///|
/// step processes the next opcode and updates r.state. If the opcode
/// emits a row in the line table, this updates *entry and returns
/// true.
fn LineReader::step(r : LineReader, entry : LineEntry) -> Bool raise {
  let opcode = r.buf.uint8().reinterpret_as_int()
  if opcode >= r.opcode_base {
    /// Special opcode [DWARF2 6.2.5.1, DWARF4 6.2.5.1]
    let adjusted_opcode = opcode - r.opcode_base
    r.advance_pc(adjusted_opcode / r.line_range)
    let line_delta = r.line_base + adjusted_opcode % r.line_range
    r.state.line += line_delta
    /// goto emit
    copy_line_entry(entry, r.state)
    r.state.basic_block = false
    r.state.prologue_end = false
    r.state.epilogue_begin = false
    r.state.discriminator = 0
    return true
  }
  match opcode {
    0 => {
      /// Extended opcode [DWARF2 6.2.5.3]
      let length = r.buf.uint().to_uint()
      let start_off = r.buf.off
      let opcode = r.buf.uint8()
      if opcode == LneEndSequence {
        r.state.end_sequence = true
        copy_line_entry(entry, r.state)
        r.reset_state()
        return true
      } else if opcode == LneSetAddress {
        match r.addrsize {
          1 => r.state.address = r.buf.uint8().to_uint64()
          2 => r.state.address = r.buf.uint16().to_uint64()
          4 => r.state.address = r.buf.uint32().to_uint64()
          8 => r.state.address = r.buf.uint64()
          _ => ignore(r.buf.error("unknown address size"))
        }
      } else if opcode == LneDefineFile {
        let done = r.read_file_entry()
        if done {
          r.buf.err = Some(
            DecodeError::new(
              "line", start_off, "malformed DW_LNE_define_file operation",
            ),
          )
          return false
        }
        r.update_file()
      } else if opcode == LneSetDiscriminator {
        /// [DWARF4 6.2.5.3]
        r.state.discriminator = r.buf.uint().to_int()
      }
      r.buf.skip((start_off + length - r.buf.off).reinterpret_as_int())
      if opcode == LneEndSequence {
        return true
      }
    }

    /// Standard opcodes [DWARF2 6.2.5.2]
    opcode if opcode == LnsCopy.reinterpret_as_int() => {
      /// goto emit
      copy_line_entry(entry, r.state)
      r.state.basic_block = false
      r.state.prologue_end = false
      r.state.epilogue_begin = false
      r.state.discriminator = 0
      return true
    }
    opcode if opcode == LnsAdvancePc.reinterpret_as_int() =>
      r.advance_pc(r.buf.uint().to_int())
    opcode if opcode == LnsAdvanceLine.reinterpret_as_int() =>
      r.state.line += r.buf.int().to_int()
    opcode if opcode == LnsSetFile.reinterpret_as_int() => {
      r.file_index = r.buf.uint().to_int()
      r.update_file()
    }
    opcode if opcode == LnsSetColumn.reinterpret_as_int() =>
      r.state.column = r.buf.uint().to_int()
    opcode if opcode == LnsNegateStmt.reinterpret_as_int() =>
      r.state.is_stmt = not(r.state.is_stmt)
    opcode if opcode == LnsSetBasicBlock.reinterpret_as_int() =>
      r.state.basic_block = true
    opcode if opcode == LnsConstAddPc.reinterpret_as_int() =>
      r.advance_pc((255 - r.opcode_base) / r.line_range)
    opcode if opcode == LnsFixedAdvancePc.reinterpret_as_int() =>
      r.state.address += r.buf.uint16().to_uint64()

    /// DWARF3 standard opcodes [DWARF3 6.2.5.2]
    opcode if opcode == LnsSetPrologueEnd.reinterpret_as_int() =>
      r.state.prologue_end = true
    opcode if opcode == LnsSetEpilogueBegin.reinterpret_as_int() =>
      r.state.epilogue_begin = true
    opcode if opcode == LnsSetISA.reinterpret_as_int() =>
      r.state.isa = r.buf.uint().to_int()
    _ =>
      /// Unhandled standard opcode. Skip the number of
      /// arguments that the prologue says this opcode has.
      for i = 0; i < r.opcode_lengths[opcode]; i = i + 1 {
        ignore(r.buf.uint())
      }
  }
  false
}

///|
/// advancePC advances "operation pointer" (the combination of Address
/// and OpIndex) in r.state by opAdvance steps.
fn LineReader::advance_pc(r : LineReader, op_advance : Int) -> @unit.T {
  let op_index = r.state.op_index + op_advance
  r.state.address += (r.min_instruction_length *
  (op_index / r.max_ops_per_instruction)).to_uint64()
  r.state.op_index = op_index % r.max_ops_per_instruction
}

///|
/// A LineReaderPos represents a position in a line table.
struct LineReaderPos {
  /// off is the current offset in the DWARF line section.
  off : Offset
  /// num_file_entries is the length of file_entries.
  num_file_entries : Int
  /// state and file_index are the statement machine state at
  /// offset off.
  state : LineEntry
  file_index : Int
}

///|
/// Tell returns the current position in the line table.
pub fn LineReader::tell(r : LineReader) -> LineReaderPos {
  LineReaderPos::{
    off: r.buf.off,
    num_file_entries: r.file_entries.length(),
    state: r.state,
    file_index: r.file_index,
  }
}

///|
/// Seek restores the line table reader to a position returned by LineReader.tell.
///
/// The argument pos must have been returned by a call to LineReader.tell on this
/// line table.
pub fn LineReader::seek(r : LineReader, pos : LineReaderPos) -> @unit.T {
  r.buf.off = pos.off
  r.buf.data = r.section[r.buf.off.reinterpret_as_int():r.end_offset.reinterpret_as_int()]
  /// FIXME: MoonBit doesn't support resizing arrays, we need to recreate
  let new_entries = Array::make(pos.num_file_entries, None)
  for i = 0; i < pos.num_file_entries && i < r.file_entries.length(); i = i + 1 {
    new_entries[i] = r.file_entries[i]
  }
  r.file_entries = new_entries
  r.state = pos.state
  r.file_index = pos.file_index
}

///|
/// Reset repositions the line table reader at the beginning of the
/// line table.
pub fn LineReader::reset(r : LineReader) -> @unit.T {
  /// Reset buffer to the line number program offset.
  r.buf.off = r.program_offset
  r.buf.data = r.section[r.buf.off.reinterpret_as_int():r.end_offset.reinterpret_as_int()]

  /// Reset file entries list.
  /// FIXME: MoonBit doesn't support resizing arrays, we need to recreate
  let new_entries = Array::make(r.initial_file_entries, None)
  for i = 0
      i < r.initial_file_entries && i < r.file_entries.length()
      i = i + 1 {
    new_entries[i] = r.file_entries[i]
  }
  r.file_entries = new_entries

  /// Reset line number program state.
  r.reset_state()
}

///|
/// resetState resets r.state to its default values
fn LineReader::reset_state(r : LineReader) -> @unit.T {
  /// Reset the state machine registers to the defaults given in
  /// [DWARF4 6.2.2].
  r.state = LineEntry::{
    address: 0UL,
    op_index: 0,
    file: None,
    line: 1,
    column: 0,
    is_stmt: r.default_is_stmt,
    basic_block: false,
    prologue_end: false,
    epilogue_begin: false,
    isa: 0,
    discriminator: 0,
    end_sequence: false,
  }
  r.file_index = 1
  r.update_file()
}

///|
/// Files returns the file name table of this compilation unit as of
/// the current position in the line table. The file name table may be
/// referenced from attributes in this compilation unit such as
/// AttrDeclFile.
///
/// Entry 0 is always nil, since file index 0 represents "no file".
///
/// The file name table of a compilation unit is not fixed. Files
/// returns the file table as of the current position in the line
/// table. This may contain more entries than the file table at an
/// earlier position in the line table, though existing entries never
/// change.
pub fn LineReader::files(r : LineReader) -> Array[LineFile?] {
  r.file_entries
}

///|
/// SeekPC sets *entry to the LineEntry that includes pc and positions
/// the reader on the next entry in the line table. If necessary, this
/// will seek backwards to find pc.
///
/// If pc is not covered by any entry in this line table, SeekPC
/// raises UnknownPCError. In this case, *entry and the final seek
/// position are unspecified.
///
/// Note that DWARF line tables only permit sequential, forward scans.
/// Hence, in the worst case, this takes time linear in the size of the
/// line table. If the caller wishes to do repeated fast PC lookups, it
/// should build an appropriate index of the line table.
pub fn LineReader::seek_pc(
  r : LineReader,
  pc : UInt64,
  entry : LineEntry,
) -> @unit.T raise {
  r.next(entry) catch {
    err => raise err
  }
  if entry.address > pc {
    /// We're too far. Start at the beginning of the table.
    r.reset()
    r.next(entry) catch {
      err => raise err
    }
    if entry.address > pc {
      /// The whole table starts after pc.
      r.reset()
      raise UnknownPCError
    }
  }

  /// Scan until we pass pc, then back up one.
  for {
    let next_entry = LineEntry::{
      address: 0UL,
      op_index: 0,
      file: None,
      line: 0,
      column: 0,
      is_stmt: false,
      basic_block: false,
      prologue_end: false,
      epilogue_begin: false,
      isa: 0,
      discriminator: 0,
      end_sequence: false,
    }
    let pos = r.tell()
    try {
      r.next(next_entry)
      if next_entry.address > pc {
        if entry.end_sequence {
          /// pc is in a hole in the table.
          raise UnknownPCError
        }
        /// entry is the desired entry. Back up the
        /// cursor to "next" and return success.
        r.seek(pos)
        return
      }
      copy_line_entry(entry, next_entry)
    } catch {
      @io.EOF => ()
      err => raise err
    }
  }
}

///|
/// pathIsAbs reports whether path is an absolute path (or "full path
/// name" in DWARF parlance). This is in "whatever form makes sense for
/// the host system", so this accepts both UNIX-style and DOS-style
/// absolute paths. We avoid the filepath package because we want this
/// to behave the same regardless of our host system and because we
/// don't know what system the paths came from.
fn path_is_abs(path : @string.View) -> Bool raise {
  let (_, path) = split_drive(path)
  path.length() > 0 && (path[0] == '/' || path[0] == '\\')
}

///|
/// pathJoin joins dirname and filename. filename must be relative.
/// DWARF paths can be UNIX-style or DOS-style, so this handles both.
fn path_join(
  dirname : @string.View,
  filename : @string.View,
) -> @string.View raise {
  if dirname.length() == 0 {
    return filename
  }
  /// dirname should be absolute, which means we can determine
  /// whether it's a DOS path reasonably reliably by looking for
  /// a drive letter or UNC path.
  let (drive, dirname) = split_drive(dirname)
  let mut dirname = dirname
  if drive.length() == 0 {
    /// UNIX-style path.
    return path_join_unix(dirname, filename)
  }
  /// DOS-style path.
  let (drive2, filename) = split_drive(filename)
  if drive2.length() != 0 {
    if !(drive == drive2) {
      /// Different drives. There's not much we can
      /// do here, so just ignore the directory.
      return drive2 + filename
    }
    /// Drives are the same. Ignore drive on filename.
  }
  if !(dirname.has_suffix("/") || dirname.has_suffix("\\")) &&
    dirname.length() != 0 {
    let sep = if dirname.has_prefix("/") { "/" } else { "\\" }
    dirname = dirname + sep
  }
  drive + dirname + filename
}

///|
/// UNIX-style path join
fn path_join_unix(
  dirname : @string.View,
  filename : @string.View,
) -> @string.View {
  if dirname.length() == 0 {
    return filename
  }
  if dirname.has_suffix("/") {
    return dirname + filename
  }
  dirname + "/" + filename
}

///|
/// splitDrive splits the DOS drive letter or UNC share point from
/// path, if any. path == drive + rest
fn split_drive(path : @string.View) -> (@string.View, @string.View) raise {
  if path.length() >= 2 && path[1] == ':' {
    let c = path[0]
    if c is ('a'..='z' | 'A'..='Z') {
      return (path[:2], path[:2])
    }
  }
  if path.length() > 3 &&
    (path[0] == '\\' || path[0] == '/') &&
    (path[1] == '\\' || path[1] == '/') {
    /// Normalize the path so we can search for just \ below.
    let npath = path.replace(old="/", new="\\")
    /// Get the host part, which must be non-empty.
    let slash1 = match npath[2:].find("\\") {
      Some(idx) => idx + 2
      None => -1
    }
    if slash1 > 2 {
      /// Get the mount-point part, which must be non-empty.
      let slash2 = match npath[slash1 + 1:].find("\\") {
        Some(idx) => idx + slash1 + 1
        None => -1
      }
      if slash2 > slash1 {
        return (path[:slash2], path[slash2:])
      }
    }
  }
  ("", path)
}
